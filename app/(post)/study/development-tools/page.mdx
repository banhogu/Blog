---
title: 다양한 개발 환경 툴에 대해 알아보자.
tag: study
description: 다양한 개발 환경 툴에 대해 알아봅시다 npm, nvm, bundler, webpack
subTitle: 다양한 개발 환경 툴에 대해 알아봅시다 npm, nvm, bundler, webpack
date: 2023-12-18
---

import { FileName } from '@/components/ui/FileName';
import { Callout } from '@/components/ui/callout';

## npm

![](/images/study/development-tools/1.png)

### **npm이란?**

> npm이란 Node Package Manager의 약자로 말 그대로 노드 패키지를 관리해주는 툴이다. node.js를 설치하면 자동으로 설치된다.

<br />

### npm을 사용하는 이유

- npm을 사용하면 전 세계의 개발자들이 자바스크립트로 만든 다양한 패키지를 npm 온라인 데이터베이스에 올리고 사용자는 그것을 npm과 같은 패키지 관리자를 통해 설치 및 삭제가 가능하다. 또한 CLI를 통해서 패키지 설치, 삭제 뿐만 아니라 패키지의 버전 관리, 의존성 관리 역시 편하게 할 수 있다. 즉 Node.js로 개발된 프로그램(npm 패키지)를 편리하게 설치, 업데이트 및 삭제 해 주는 프로그램이고 npm 명령어를 통해 npm 서비스에 등록된 Node.js로 작성된 패키지를 관리한다.
- 예를 들자면 안드로이드 폰으로 어플을 다운 받기 위해 우린 구글 플레이 스토어를 이용한다. 여기서 안드로이드는 Node.js 가 되겠고, 어플은 패키지, 구글 플레이 스토어는 NPM이라고 할 수 있다.

<br />

## nvm

![](/images/study/development-tools/2.png)

### **nvm이란?**

> Node Version Manager의 약자로 쉽게 말해서 Node.js를 설치하기 위한 툴이다. Node.js를 설치하는 방법은 여러가지이지만, nvm을 먼저 설치하지 않고 OS에서 node.js를 직접 설치하게 되면 여러 버전의 Node.js를 설치해야 하는 경우나 기타 문제에 대응하기 어려워진다.

<br />

### nvm을 사용하는 이유

- 예를 들어 node 12.18.3 버전에서 내가 짠 코드가 잘 실행이 되었는데, node 14.15.5 버전에서는 실행이 되지 않는 경우가 있을 수 있다. 이럴 경우, node 12.18.3에서 코드를 테스트하면 된다.
- 그러나, 만약 내가 설치한 node가 14.15.5 버전일 경우에는 문제가 생길 수 있다. 이 경우, node를 업데이트 해야 한다. 업데이트 자체는 쉽게 할 수 있지만, 다시 이전 버전의 node로 돌아가고 싶을 때, node를 지우고 다시 설치하는 과정을 반복해야 한다. 이런 경우가 빈번하게 일어난다면 매우 귀찮아질 수 있다. nvm을 설치하면, 이런 버전 관리 문제를 쉽게 해결할 수 있게 된다. 그렇기 때문에 nvm을 꼭 먼저 설치하고, nvm을 통해 원하는 버전의 Node.js 설치하는 것이 좋다.

<br />

### 설치 순서

일반적으로 권장 하는 설치 순서는

> nvm ➝ Node.js ➝ npm

1. nvm을 먼저 설치한다.
2. 원하는 조건 혹은 버전으로 Node.js를 설치한다.
3. npm을 이용해 필요한 패키지를 때마다 추가로 설치한다.

<br />

## npm nvm 요약

Nodejs 개발이 장점 중 하나로 npm을 이용하여 다른 개발자가 이미 개발해 놓은 모듈들을 가져다가 사용할 수 있다. npm이란 Node Packaged Manager로 Nodejs로 개발된 모듈을 관리한다는 뜻이다. 여기서 Package 란 프로그램을 구성하는 작은 단위를 말하는데 다른 말로 모듈(module) 이라고도 한다.

쉽게 설명하자면 게시판이 큰 의미의 프로그램이라면 글 보기, 글쓰기, 글 삭제, 글 수정, 글목록 등 이런 하나하나를 모듈이라 생각하면 된다. 이렇게 다른 개발자가 이미 개발해 놓은 모듈을 가져다 쓰면 편리하기도 하지만 생각지도 않은 문제가 발생되기도 한다.

그 중 하나의 예로 들자면 내가 프로그램 개발을 위하여 설치한 node 버전이 사용하려는  package (모듈)의 node 버전과 맞지 않을 경우 프로그램 실행이 오류를 발생하기도 한다. 그래서 사용하는 모듈이 중요한 모듈이고 개발하는데 시간이 걸릴 수 있는 모듈이라면 사용하려는 모듈의 nodejs 버전을 메인 버전으로 나의 시스템에 설치된 nodejs의 버전을 맞혀 주어야 한다.

이미 노드 18 버전이 설치되어 있는 데 사용하려는 모듈이 노드 16 버전 만을 지원한다면 나의 시스템에 설치되어 있는 18 버전의 노드를 삭제하고 16 버전으로 다시 설치를 해 주어야 하는 것이다. 이러한 불편한 점을 개선하기 위하여 nvm (Node Version Manager) 을 설치하여 사용한다.

<br />

## package.json

### package.json이란?

> package.json이란 현재 프로젝트에 관한 정보와 패키지 매니저(npm, yarn)을 통해 설치한 모듈들의 의존성을 관리하는 파일이다.

<br />

### 의존성을 관리한다는 의미

- Node.js 프로젝트에서는 많은 패키지를 사용하게 되고 패키지의 버전도 빈번하게 업데이트 된다. 일반적인프로젝트는 다수의 인원이 참여하여 개발하기 때문에 프로젝트가 의존하고 있는 패키지를 일괄적으로 관리해야 같은 버전의 패키지를 사용함으로써 프로젝트의 일관성을 유지하고 버그나 호환성 문제를 최소화하는 데 도움이 된다.
- 따라서 npm을 이용하여 package.json 파일을 통해서 프로젝트 정보와 패키지의 의존성을 관리한다. 프로젝트에 사용되는 모듈들이 설치될 때마다 package.json 파일의 dependencies에는 해당 모듈들의 내용이 추가가 된다. 이로써 설치된 모듈들을 공동 작업 레포지토리에 업로드 및 다운로드 할 필요없이, package.json에 명시된 의존성 모듈들을 모두 설치할 수 있다. 즉, 이미 작성된 package.json 파일이 있다면 팀 내에 배포하여 동일한 개발환경을 빠르게 구축할 수 있게 된다.

<br />

```jsx
{
  "name": "react-sample",
  "version": "0.1.0",
  "private": true,
  "dependencies": { // !의존성 관리 부분!
    "@testing-library/jest-dom": "^5.16.4",
    "@testing-library/react": "^13.1.1",
    "@testing-library/user-event": "^13.5.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  }
```

<br />

## Bundler

![](/images/study/development-tools/3.png)

### **번들러(Bundler)의 탄생 배경**

> 인터넷이 등장하고 처음에는 웹 페이지와 서비스들의 규모가 그렇게 크지 않았다. 때문에 이를 구성하는 HTML이나 자바스크립트 파일의 크기도 상대적으로 작았고 해당 서비스를 유지하는데 큰 무리가 없었다. 하지만 인터넷이 발달하면서, 적게는 수 십 만 줄에서 많게는 수 백 만 줄의 코드로 이루어진 대규모 웹 서비스들이 생겨나기 시작했다. 하나의 웹 서비스에서 수십 수백개의 자바스크립트 파일을 다루면서 여러 문제들이 발생했다.

<br />

### **중복된 이름으로 인한 충돌, 위험**

- 대규모 웹페이지의 경우, 엄청난 개수의 JavaScript 파일로 구성되며, 한 사람도 아니고 여러 사람이 웹 서비스 개발에 참여하므로 서로 만든 함수명과 변수명이 겹치는 일이 일어난다. 이렇게 함수명과 변수명이 같은 경우 언제 어디서 충돌이 일어날 지 모르는 위험이 존재한다.

### **파일 전송 속도 문제**

- 사용자가 브라우저에서 URI를 입력하면 서버는 그에 해당하는 파일을 사용자에게 제공한다. 웹 애플리케이션을 구성하는 파일의 양이 많을수록 사용자에게 해당 파일을 제공하는 시간이 오래 걸리게 된다.
- 게다가, 파일 하나의 크기도 크다면 사용자는 요청한 웹 서비스를 받기까지 상당히 오랜 시간 기다려야 할 것이다. 그렇다고 파일 하나에 모든 스크립트를 작성하기엔 추후 유지보수 측면에서 최악의 방법이 된다.<br/><br/>

### **번들링을 했을 때의 장점은?**

- 이전에는 각 파일들마다 서버에 요청하여 자원을 얻어와야 했던 반면, 같은 타입(ex. `html`, `css`, `js`)의 파일을 묶어서 요청/응답을 받기 때문에 네트워크적 비용이 줄게 된다.

- 여러 개의 파일을 묶어 하나의 번들로 만들 때 파일끼리의 연관관계(종속성, 의존성)을 알아서 확인하여 사용하지 않은 파일은 포함하지 않기 때문에, 번들의 크기를 줄여 페이지 로딩을 더욱 빠르게 한다.

- 번들러를 사용하면 **모듈 단위 코딩**이 가능해진다. 모듈 단위 코딩을 하면 각 모듈이 독립적인 공간이므로 앞에서 문제가 되었던 '변수명 중복'으로 인한 예상치 못한 에러의 발생을 막을 수 있다. 또한 모듈 단위 코딩으로 코드의 가독성과 유지보수의 편리함을 향상시킬 수 있다.<br/><br/>

### 모듈 단위 코딩의 의미

![](/images/study/development-tools/4.png)

<Callout>
💡 개발하는 애플리케이션의 크기가 커지면 파일을 여러개로 분리하게 된다. 이때 분리된 파일 각각을 '모듈(module)'이라고 부른다. ES5, ES6의 `[ export (name,default) | import ]` 문법을 사용하여 쉽게 모듈을 만들 수 있다. 플러그인 파일이나 잘개 쪼개진 자바스크립트 코드 조각을 재사용하기 위해서 각각의 파일을 등록하고, 등록된 파일을 자바스크립트에서 불러와서 사용할 수 있게 된다.

</Callout>

<br />

### 모듈 단위 코딩의 필요성

- **기능의 분리가 가능하고 인터페이스가 단순해진다 :** 하나의 파일에 많은 기능들을 작성하게 되면 코드 의미 파악이 어려워지고 관리가 어려워 진다. 그렇기 때문에 하나의 파일로 관리하는 것이 아니라 각 기능 별로 파일을 분리해서 관리 하는 것이 필요하다

- **각 모듈은 자신만의 스코프를 보장해준다 :** 한 파일 내에 모든 코드를 관리하면 변수나 함수가 중복되거나 다른 기능의 코드끼리 영향을 줄 수 있다. 따라서 기능 별로 코드를 분리하여 여러 파일로 나누면 서로 분리된 파일끼리는 영향을 주고받지 않는다.

- **모듈 재사용으로 개발과 유지보수가 용이해진다 :** 예를 들어 공통된 기능이나 UI를 사용하는 부분이 있다면 우리는 이를 공통 컴포넌트로 분리하여 어디서든 사용할 수 있다.

<br />

### 번들러 기능 요약

- 쉽게 말해 지정한 메인 파일에서 시작하여 자바스크립트의 require과 import(ES6)문을 참고하여 프로젝트의 모든 의존성을 조사하고 로더를 이용해 처리한 후 번들로 묶은 자바스크립트 파일을 생성한다. 모듈 번들러의 핵심 작업은 여러 JS 파일을 하나로 결합하여 단일 파일을 만드는 것이다.
- 따라서 브라우저는 하나의 단일 파일을 로드하는 것 만으로도 애플리케이션이 동작한다. JS뿐만 아니라 CSS, 이미지, 글꼴 등 여러 리소스에 대해서도 번들링 할 수 있다. 또한 번들러는 모듈 시스템을 활용하여 각 파일을 모듈로 취급하고, 파일 간에 변수 충돌을 방지한다. 모듈 시스템을 사용하면 파일 간의 스코프가 격리되므로 변수명이 중복되더라도 충돌하지 않는다.

<br />

## Webpack

![](/images/study/development-tools/5.png)

### Webpack이란?

> 웹팩은 웹 애플리케이션에서 사용하는 수많은 리소스를 하나의 파일로 병합 및 압축 해주는 모듈 번들러이다.

<br />

### **자바스크립트에서의 모듈**

자바스크립트에서의 모듈이란 특정 기능을 가진 코드들을 하나의 파일로 관리하는 것을 의미한다.

<FileName>date.js</FileName>

```jsx
**date.js**
export const getIosStringDate() => new Date().toISOString();
export const getNumberDate() => new Date().valueOf();
```

> 예를들어 위 date.js는 날짜를 parsing 하는 기능들을 가진 모듈이라고 할 수 있다.

<br />

### **웹팩에서의 모듈**

> 웹팩에서의 모듈은 자바스크립트 모듈뿐만이 아니라 HTML, CSS, Javascript, Images, Font 등 웹 애플리케이션을 구성하는 모든 자원들을 모듈이라고 한다.

<br />

### **파일 단위의 자바스크립트 모듈 관리의 필요성**

- 자바스크립트의 변수 유효 범위 (스코프)는 기본적으로 전역 범위를 기본으로 가진다. 즉, 어디서든 변수에 접근할 수 있다는 말이다. 파일 단위로 자바스크립트 코드를 관리할 때 모듈화 하지 않으면 어떤 문제가 발생하는지 예를 들어 알아보자.

<FileName>module1.js</FileName>

```jsx
var foo = 10;
```

<br />

<FileName>module1.js</FileName>

```jsx
foo = 20;
```

<br />

<FileName>main.html</FileName>

```html
<body>
  <script src="./module1.js"></script>
  <script src="./module2.js"></script>
  <script>
    console.log(foo); // 20
  </script>
</body>
```

위 코드에서 foo는 전역 변수이기 때문에 어디서든 접근할 수 있고 값을 변경할 수 있다. 프로젝트가 커지고 이러한 변수가 많아진다면 남이 사용한 변수를 실수로 변경할 수 있는 문제 등이 발생한다. 그리고 script의 순서를 바꾸면 foo의 값도 바뀌게 된다.

이러한 문제를 해결하기 위해 javascript 파일을 모듈로 관리하게 되었고, CommonJS, AMD, ESModule 등의 모듈 시스템이 만들어졌다. 웹팩은 다양한 모듈화 방식 중 ESModule 방식을 사용하고 있다.<br /><br />

### **웹 애플리케이션의 빠른 로딩 속도와 높은 성능**

웹페이지에 접속하게 되면 js, image, font 등의 수많은 리소스 파일들이 다운 받아지게 된다.

![](/images/study/development-tools/6.png)

만약 페이지에서 사용하는 js파일이 5개라면 위와 같이 5개의 js파일을 다운로드하게 되는데 5개가 아니라 수천 개라면 그리고 사이즈가 크다면 로딩 시간에 지친 사용자들은 페이지를 나갈지도 모른다.

<br />

```jsx
<body>
  <script src="./module1.js"></script>
  <script src="./module2.js"></script>
  <script src="./module3.js"></script>
  <script src="./module4.js"></script>
  <script src="./module5.js"></script>
  ...
  <script src="./module1000.js"></script>
</body>
```

이러한 문제를 해결하기 위해 웹팩은 여러 파일을 하나로 병합 및 압축하는 기능을 제공하고 있다. 그 결과 서버로의 수많은 요청을 줄이기 때문에 네트워크에 부담을 줄여 더 빠른 서비스를 제공할 수 있다. 예제에서는 js 파일을 위주로 설명했지만 위에서도 말했다시피 웹팩은 js 뿐만이 아니라 모든 리소스를 모듈로 취급하고 그 리소스들을 하나의 파일로 병합 및 압축할 수 있다. 이 작업은 Loader를 통해 할 수 있다.

<br />
